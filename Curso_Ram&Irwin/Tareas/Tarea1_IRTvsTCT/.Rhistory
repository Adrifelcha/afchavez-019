sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
p_valor <- pchisq(G2, gl, lower.tail=F)m
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Hola")
}else{
print"Adios"
}
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
p_valor <- pchisq(G2, gl, lower.tail=F)m
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Hola")
}else{
print("Adios")
}
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
p_valor <- pchisq(G2, gl, lower.tail=F)m
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Cae en Zona Crítica : Se rechaza la HO")
}else{
print("cae en Zona de Confianza: Se mantiene la HO")
}
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
decision
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
#Computamos el área sobre el estadístico G^2 e una Distribución Chi-cuadrada con (Parámetros_2 - Parámetros_1) Grados de Libertad
p_valor <- pchisq(G2, gl, lower.tail=F)
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Cae en Zona Crítica : Se rechaza la HO")
}else{
print("cae en Zona de Confianza: Se mantiene la HO")
}
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
#Computamos el área sobre el estadístico G^2 e una Distribución Chi-cuadrada con (Parámetros_2 - Parámetros_1) Grados de Libertad
p_valor <- pchisq(G2, gl, lower.tail=F)
#Comparamos el área con el nivel de significancia (la probabilidad de caer en la Zona Crítica)
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Cae en Zona Crítica : Se rechaza la HO")
}else{
print("cae en Zona de Confianza: Se mantiene la HO")
}
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
#Computamos el área sobre el estadístico G^2 e una Distribución Chi-cuadrada con (Parámetros_2 - Parámetros_1) Grados de Libertad
p_valor <- pchisq(G2, gl, lower.tail=F)
#Comparamos el área con el nivel de significancia (la probabilidad de caer en la Zona Crítica)
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Cae en Zona Crítica : Se rechaza la HO")
}else{
print("cae en Zona de Confianza: Se mantiene la HO")
}
#Imprimimos los resultados
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
#### Ejemplo 1  : Contraste de Hipótesis por Razón de Verosimilitud
##### Ho: La Media vale 100  <- Parámetro fijo
##### Ha: La Media es distinta de 100   <- Parámetro libre
x <- c(116, 85, 90, 125)  # Muestra
lk <- 0 #Creamos un arreglo vacío, que llenaremos con la función de verosimilitud
#La Funcion de Verosimilitud es la multiplicatoria de la funcion de densidad
likelihood <- function(mu, sigma){    #La función de verosimilitud de una norma depende de sus parámetros Mu y Sigma
lk <- 1   #Valor inicial para la multiplicatoria
for(i in 1:length(x)){   #Por cada elemento contenido en la muestra
lk <- lk * dnorm(x[i], mu, sigma)   #Se definirá una verosimilitud que corresponde al  valor computado en la repetición anterior por la función de densidad Normal (que depende de los datos y los parámetros a estimar)
}
return(lk)   #En esta función, nos interesa recuperar el valor computado para la verosimilitud
}
media <- mean(x)  #Estimamos la media de nuestra muestra
desviacion <- sd(x) #Y la desviación estandar
M1 <- likelihood(100, desviacion)   #Calculamos la Verosimilitud para el Modelo 1, que restringe Mu a 100, y estima Sigma a partir de la muestra (desviación estándar)
M2 <- likelihood(media, desviacion) #Calculamos la verosimilitud para el Modelo General, que estima Mu y Sigma a partir de la muestra (su Media y Desviación Estándar)
razon <- M1/M2 #Computamos la Razón de las Verosimilitudes computadas
#Imprimimos los resultados:
print(paste("La media de los datos es ", media, " y su desviación estándar ", round(desviacion,3)))
cat(
sprintf('La Verosimilitud del Modelo 1 es %14.12f; la del Modelo 2, es %14.12f',M1, M2))
print(paste("La Razón de las Verosimilitudes (lk(M1)/lk(M2)) es ", round(razon,4)))
#Evaluamos el Contraste de la Bondad de Ajustes
alpha <- 0.05  #Probabilidad de caer en la zona crítica
G2 = -2*log(razon)  #Computamos el Estadístico G^2
gl <- 1  #La diferencia entre los parámetros libres en el Modelo General (2 parámetros) y el Modelo Anidado (1 parámetro)
#Computamos el área sobre el estadístico G^2 e una Distribución Chi-cuadrada con (Parámetros_2 - Parámetros_1) Grados de Libertad
p_valor <- pchisq(G2, gl, lower.tail=F)
#Comparamos el área con el nivel de significancia (la probabilidad de caer en la Zona Crítica)
decision <- ifelse(p_valor <= alpha, "Rechazar H0", "Mantener H0")
#Otra forma de expresar el ciclo ifelse sería:
if(p_valor <= alpha){
print("Cae en Zona Crítica : Se rechaza la HO")
}else{
print("cae en Zona de Confianza: Se mantiene la HO")
}
#Imprimimos los resultados
cat(sprintf('G2 = %5.2f, gl = %1.0f p = %5.3f. Decision: %s', G2, gl, p_valor, decision))
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- seq(0,8,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l', main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l', main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 2 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 2 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- seq(0,10,.01)  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,10), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,10), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 2 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,10), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 0 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,10), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 9 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,10), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 9 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,1), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 9 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8), ylim=c(0,0.5), main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
### Pesentando la Chi Cuadrada
######
Gl <- 1 #El valor del parámetro lambda
x <- 0:10  #Definimos una base arbitraria
Ex_Chi <- dchisq(x, Gl)   #Creamos una Poisson con la lambda definida
#### Graficamos
layout(matrix(1:1,ncol=1)) #Presentamos un sólo gráfico en una sola columna por página
plot(Ex_Chi, type='l',xlim=c(0,8),  main="Distribución Chi-cuadrada", xlab="Conteo de casos",
cex.lab=1.3, cex.main=2, col="indianred", lwd=3, lty=3)
setwd("C:/Users/Adriana/Desktop/Adrifelcha_PsicometriaYEvaluacion/Lancaster/Reporte_01")
Datos <- read.csv("Respuestas.csv")
View(Datos)
Datos$NO.
source('~/.active-rstudio-document', echo=TRUE)
max(unique(Datos$NO.))
source('~/.active-rstudio-document', echo=TRUE)
min(unique(Datos$NO.))
#############
#############
setwd("C:/Users/Adriana/Desktop/Adrifelcha_PsicometriaYEvaluacion/Lancaster/Reporte_01")
Datos <- read.csv("Respuestas.csv")
#############
#############
setwd("C:/Users/Adriana/Desktop/Adrifelcha_PsicometriaYEvaluacion/Lancaster/Reporte_01")
Datos <- read.csv("Respuestas.csv")
Datos$NUMERO <- NULL
View(Datos)
ncol(Datos)
nrow(Datos)
Clave <- c("B", "C")
Clave[2]
#############################################################
rm(list=ls())                       #Limpiamos variables
setwd("C:/Users/Adriana/Desktop/Adrifelcha_PsicometriaYEvaluacion/Curso_Ram&Irwin/Tareas/Tarea1_IRTvsTCT")
############################################################
Datos <- read.csv("Tarea1_Datos.csv")    #Datos a trabajar
Datos$Id <- NULL        #Eliminamos las columnas innecesarias
Datos$Sexo <- NULL      #para el análisis de Rasch
Datos$X <- NULL
View(Datos)           #Echamos un vistazo a la base final
###################################################
###################################################
#######
####### Beta (IRT) vs Dificultad p (TTC)
###################################################
##############  Calcula para cada ítem el índice de dificultad (p) en el marco de la Teoría Clásica de los Tests (TCT).
P <- NULL
Items <- c(1:12)
for(a in 1:length(Items)){
P[a] <- mean(Datos[,a])
}
P
Dif_TCT <- matrix(data=c(Items,P),ncol=2)      #Ordenamos el valor computado por cada item en una matriz
colnames(Dif_TCT) <- c("Item", "Dificultad (P)")                  #asignamos un nombre a cada columna
Dif_TCT         #Imprimimos la matriz resultante
########
##################################################
##############  Ajusta el modelo de Rasch a los datos para obtener estimaciones de los parámetros de dificultad (Beta) de los ítems.
library(mirt)
Rasch <- mirt(Datos, 1, itemtype = 'Rasch')
rep_coef<-data.frame(coef(Rasch, simplify=TRUE)$items)
b<- -1*(rep_coef$d/rep_coef$a1)
rep<-cbind(rep_coef,b)
rep <- subset(rep, select=5); round(rep,3)
install.packages("mirt")
##################################################
##############  Ajusta el modelo de Rasch a los datos para obtener estimaciones de los parámetros de dificultad (Beta) de los ítems.
library(mirt)
Rasch <- mirt(Datos, 1, itemtype = 'Rasch')
rep_coef<-data.frame(coef(Rasch, simplify=TRUE)$items)
b<- -1*(rep_coef$d/rep_coef$a1)
rep<-cbind(rep_coef,b)
rep <- subset(rep, select=5); round(rep,3)
Comparacion <- matrix(data=c(P,round(b, 3)),ncol=2)      #creamos una matriz con p en una columna y b en otra
colnames(Comparacion) <- c("p", "Beta")
Comparacion         #Imprimimos la matriz resultante
########## Theta (IRT) vs X (TTC)
###################################################
############## Calcula para cada persona su puntuación (X) en el marco de la TCT (es decir, el núumero de veces que responde
############## "Sí, es aceptable" en las 12 preguntas).
X <- NULL
Personas <- nrow(Datos)
for(a in 1:Personas){
X[a] <- sum(Datos[a,Items])
}
X
table(X)
theta <- fscores(Rasch, method='WLE')                      #fscores nos permite calcular theta para cada persona, a partir de los datos que ya
#habíamos estimado previamente con mirt y guardado en Rasch
#WLE es el método, hay varios, (código 07 - linea 46)
theta
###########    Obten estimaciones para los parametros (theta) de las personas en el modelo de Rasch.
theta <- fscores(Rasch, method='WLE')                      #fscores nos permite calcular theta para cada persona, a partir de los datos que ya
#habíamos estimado previamente con la función mirt y guardado en el objeto "Rasch"
#WLE es el método, hay varios, (código 07 - linea 46)
theta  #Imprimimos el resultado
#Ahora, responde las siguientes preguntas:
#(a) Representa las variables x y theta graficamente a traves de un diagrama de puntos. Describe, con base en esta grafica, la relacion entre
#    las variables x y theta.
plot(X,theta, pch=16, main = "Comparación gráfica entre T (TCT) y Theta (TRI)",
xlab="T - TCT", ylab = "Theta - TRI")
#(c) ¿Los datos dan evidencia de una diferencia global entre hombres y mujeres respecto de su actitud hacia el veganismo? Justifica tu respuesta.
datos <- read.csv("Tarea1_Datos.csv")    #Datos a trabajar
sexo <- matrix(data=c(datos$Sexo,theta),nrow=length(datos[,1]),ncol=2) #creamos una matriz con el sexo de las personas y su theta
dif_sexo <- t.test(sexo[,2]~sexo[,1])                                  #realizamos una prueba t para ver si hay diferencia en funcion del sexo
dif_sexo
sexo
library(psych)             #librería que ya contiene una función para calcular alfa de cronbach
alfa <- alpha(Datos)    #usamos la función en los datos (la base con sólo items)
alfa
install.packages("psych")
library(psych)             #librería que ya contiene una función para calcular alfa de cronbach
alfa <- alpha(Datos)    #usamos la función en los datos (la base con sólo items)
alfa
#########################################
############## b) Dentro del marco del modelo de Rasch, deriva la funcion de informacion del test. (Explica, paso por paso, como se hace.)
theta_r <- matrix(seq(-6,6,.01))     #Definimos un rango de theta sobre el que queremos conocer la funcion de información
info <- testinfo(Rasch, theta_r)     #testinfo es la función para obtener la funcion de informacion
# En el caso del modelo de un parámetro (Rasch) y con respuestas dicotómicas, la función de información de un item es la probabilidad de responder
# correctamente multiplicada por la probabilidad de una respuesta incorrecta. A su vez, gracias al supuesto de que hay independencia local,
# las funcio
plot(theta_r, info, type = 'l', main = 'Información del test',           #graficamos la funcion, mientras mas estrecha, mas precisas son las
xlab=expression(paste("Habilidad, ",theta_r)),                      #estimaciones
ylab=expression(paste("Información")))
plot(theta_r, info, type = 'l', main = 'Información del test',           #graficamos la funcion, mientras mas estrecha, mas precisas son las
xlab=expression(paste("Habilidad, ",theta)),                      #estimaciones
ylab=expression(paste("Información")))
plot(theta_r, info, type = 'l', main = 'Información del test',           #graficamos la funcion, mientras mas estrecha, mas precisas son las
xlab=expression(paste("Habilidad, (",theta, ")")),                      #estimaciones
ylab=expression(paste("Información")))
plot(theta_r, info, type = 'l', main = 'Información del test',           #graficamos la funcion, mientras mas estrecha, mas precisas son las
xlab=expression(paste("Habilidad (",theta, ")")),                      #estimaciones
ylab=expression(paste("Información")))
plot(theta_r, info, type = 'l', main = 'Información del test',           #graficamos la funcion, mientras mas estrecha, mas precisas son las
xlab=expression(paste("Habilidad (Rango ",theta, ")")),                      #estimaciones
ylab=expression(paste("Información")))
